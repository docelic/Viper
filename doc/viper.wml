
<h2>Viper backend syntax reference </h2>
<p>
One large part of the complete Viper setup is the custom,
Perl-based backend for slapd (server component of the OpenLDAP
suite).
</p>
<p>
The backend was developed to solve a whole set of existing
LDAP deficiencies (well, deficiencies, at least in the
context of configuration management).
</p>
<p>
This page should be used as a reference, but its listing of all
Viper features, with concise description, usage syntax and
examples, also serves as kind of a showcase.
</p>

<div class="fineline"></div>

<h3>Configuration directives in slapd.conf</h3>

<p>
Each suffix configured in Viper/LDAP should begin with the following
block:
</p>
<pre>
database           perl
suffix             "<i>SUFFIX</i>"
perlModulePath     "/etc/ldap/viper"
perlModule         "Viper"
directory          "/var/lib/ldap/viper/"
treesuffix         "<i>SUFFIX</i>"
</pre>

The first four lines are required by slapd and its back-perl backend
to configure the suffix and initialize Viper.
</p><p>
The last two lines are required by the Viper backend, and the value of
'treesufix' should be equal to 'suffix'. (This small duplication cannot
be avoided because 'suffix' directive is consumed by slapd and is not
passed onto our backend).
</p><p>
After the above "header", the following directives can be used. The list is
sorted alphabetically, with each subtitle specifying configuration directive
name and its usage syntax. Where applicable, the first value listed
indicates the default value.

<h4>addIgnoredups 0|1</h4>
<p>
Specify whether LDAP ADD operation should ignore adds on existing entries,
without throwing LDAP_ALREADY_EXISTS error. Applicable if addoverwrites= 0.
</p>

<h4>addOverwrites 0|1</h4>
<p>
Specify whether LDAP ADD operation should overwrite existing entries,
without throwing LDAP_ALREADY_EXISTS error.
</p>

<h4>addPrompt SUFFIX PATTERN REPLACEMENT</h4>
<p>
Define SUFFIX under which server-side Debconf prompter should run.
</p>
<p>
When Debconf template is added to LDAP under a matching SUFFIX, we can assume
that its config value is already there (due to how Debconf database saving
works), and that LDAP now has full information about the question.
</p>
<p>
Viper performs s/PATTERN/REPLACEMENT/ on the template DN to derive the
exact location of the config question, and then opens a completely-functional
Debconf interface from the server to an X DISPLAY of choice.
(Note that in this scencario, the Debconf interface literally runs on the
server).
</p>
<p>
This allows an administrator to configure client hosts to Noninteractive
Debconf frontend, capturing any new Debconf questions (arising from automatic
or manual apt-get installs) on a single X display.
</p>
<p>
Depending on how exactly the host's Debconf is configured, the admin could get
to see and change the Debconf value either after everything is already
configured on the client, or, which is much more useful, directly as the
host's code is in the decision process. (It'll block waiting for the admin
to select the value).
</p>
<p>
The default configuration shown fits Viper's data model and should
generally be used without modification.
</p>
<p>
Example: Add server-side prompter under the usual Debconf tree:
<pre>
addPrompt  cn=\\S+?,cn=\\w+,ou=templates,o=  ,ou=templates,  ,ou=hosts,
</pre>
</p>

<h4>addRelocate LABEL PATTERN REPLACEMENT</h4>
<p>
Define entry relocation rule.
</p>
<p>
When Viper-aware Debconf interface runs and it encounters a new question, it
can ask the admin for both the value and the location where the question
should be saved in LDAP. That information is then passed onto the Viper backend
through the viper_location=LABEL variable that is a part of each entry.
</p>
<p>
If LABEL is defined and found, regex replacement (s/PATTERN/REPLACEMENT/)
will be performed on the entry DN to derive the target location.
</p>
<p>
This feature is used for promoting host-specific values to site-wide or
global defaults. The examples shown fit Viper's data structure and should
be usable without change.
</p>
<p>
Example: Define "Site" and "Global" labels
<pre>
addRelocate  Site    ,cn=\\S+?,ou=  ,ou=defaults,ou=
addRelocate  Global  ,*             ,ou=hosts,ou=defaults
</pre>

For more information on where exactly the site-wide and global defaults
would be located, see <a href="data.html">LDAP data structure</a>.
</p>

<h4>cacheOpen SPEC</h4>
<p>
Specify how (and how long) to cache LDIF reads from disk.
</p>
<p>
SPEC can be a pure number (implies seconds), or a specification such as 5s,
10m, 2h, 2d, 1w. It can also be a number of value uses, such as 20u,
and number of LDAP operations, 20o.
</p>
<p>
The overall best value is 1o, 
</p>

<h4>deleteTrees 1|0</h4>
<p>
Specify whether Viper should allow deleting non-leaf elements (deleting
the entry and everything under it in one go).
<p>
Whether subtree delete is requested or not can be controlled with
ldapdelete option -r, but back-perl does not pass that option onto the
backend, so deleteTrees is the single decision maker.
</p>

<h4>entryAppend ATTRIBUTE PATTERN -&gt; &lt;attr ATTRIBUTE | append PATTERN REPLACEMENT&gt;</h4>
<p>
Specify entryAppend rule, allowing adding extra attributes into an entry
before returning it to the client.
</p>
<p>
When all ATTRIBUTE PATTERN pairs match, Viper looks to append the entry with
default attributes.
</p>
<p>
The entry from which to read the attributes to append can be specified in two
ways.
</p>
<p>
One, with "attr ATTRIBUTE" (usually "attr seeAlso") -- in that case,
the attribute seeAlso is looked up in the current entry. It is expected
to contain the DN of the entry of interest.
</p>
<p>
Two, with "append PATTERN REPLACEMENT", where s/PATTERN/REPLACEMENT/ is
performed on the original DN, and the result is used as the entry from which
to pull the extra attributes.
</p>
<p>
Examples from production config:
<pre><protect>
entryAppend  objectClass "^dhcpHost$"                      \
             -&gt;                                            \
             append .+ cn=dhcpHost,ou=objectClasses,ou=defaults

entryAppend  objectClass "^dhcpSubnet$"                    \
             -&gt;                                            \
             append .+ cn=dhcpSubnet,ou=objectClasses,ou=defaults

entryAppend  dn          "^cn=default,ou=networks"         \
             objectClass "^ipNetwork$"                     \
             -&gt;                                            \
             attr seeAlso

</protect></pre>
</p>

<h4>exp MATCH_REGEX NON_MATCH_REGEX</h4>
<p>
Specify regexes that each DN must and must not match respectively, to have
overlay "exp" ran on its attributes.
</p>
<p>
The "exp" overlay enables expansion into values of other attributes, in the
current or other entry.
</p>

<h4>extension EXT</h4>
<p>
Specify file extension to use when storing server data on disk.
</p>
<p>
Viper's data is kept in a directory tree that corresponds to the LDAP
tree, where DN components are directories, and leaf nodes are files.
Each file contains one LDAP entry in LDIF format.
</p>
<p>
File extension must be specified to make directories distinguishable
from files, and the default value should rarely be changed.
</p>
<p>
Default: <tt>.ldif</tt>
</p>

<h4>file MATCH_REGEX NON_MATCH_REGEX</h4>
<p>
Specify regexes that each DN must and must not match respectively, to have
overlay "file" ran on its attributes.
</p>
<p>
The "file" overlay enables expansion into values of on-disk files, always
relative to the suffix base directory.
</p>

<h4>find MATCH_REGEX NON_MATCH_REGEX</h4>
<p>
Specify regexes that each DN must and must not match respectively, to have
overlay "find" ran on its attributes.
</p>
<p>
The "find" overlay enables re-entrant search function, where subsequent
searches are performed internally, and their values used in constructing
the final value.
</p>
<p>
This overlay shares many similarities with "exp", but contains a crucial
difference -- with "exp", you generally know where the entry and attribute
to expand to are located. With "find", you generally don't, so you perform
a search to find them.
</p>

<h4>modifyCopyOnWrite 1|0</h4>
<p>
When a MODIFY request is issued for an entry that does not really exist 
(i.e. it comes from a fallback), specify whether Viper should copy the
entry to the expected location and then modify it, or return
LDAP_NO_SUCH_OBJECT.
</p>

<h4>modifySmarts 1|0</h4>
<p>
Specify whether Viper should ignore MODIFY requests that do not result
in any real change within the entry.
</p>
<p>
Debconf's LDAP driver submits all questions loaded during a session as
modifications, regardless of whether their value has changed.
</p>
<p>
ModifySmarts was primarily added to help Viper deal with unnecessary MODIFY
requests to entries that contain dynamic values, but since that functionality
has been improved, this directive lost its initial relevance.
</p>
<p>
However, it is still useful to enable it, detect "no-op" modifications and
avoid writing to disk, preserving meaningful modification timestamps.
</p>

<h4>overlayConfig OVERLAY OPTION VALUE ...</h4>
<p>
Specify default overlay options.
</p>
<p>
OVERLAY can be an overlay name (perl, exp, file, find) or "default".
OPTION can be "cache", "prefix" or "if".
</p>

<h4>perl MATCH_REGEX NON_MATCH_REGEX</h4>
<p>
Specify regexes that each DN must and must not match respectively, to have
overlay "perl" ran on its attributes.
</p>
<p>
By default, Perl overlay is disabled as it is in fact an interface for
"eval", and is considered dangerous.
</p>

<h4>searchFallback PATTERN REPLACEMENT</h4>
<p>
Specify search fallback rule, effectively implementing default entries.
</p>
<p>
When a specific search base is requested, and it does not exist in the searched
location, it is possible to fallback to a chain of default entries. The first
entry found wins.
</p>
<p>
Examples: production examples defaulting to site-wide and global defaults
<pre><protect>
# Fallback 1: site defaults tree.
searchFallback  cn=.[^,\\s]+,ou=hosts         ou=hosts,ou=defaults
searchFallback  cn=.[^,\\s]+,ou=templates     ou=templates,ou=defaults

# Fallback 2: global defaults tree.
searchFallback  cn=.[^,\\s]+,ou=hosts,.+      ou=hosts,ou=defaults
searchFallback  cn=.[^,\\s]+,ou=templates,.+  ou=templates,ou=defaults
</protect></pre>
</p>

<h4>searchSubst KEY PATTERN ... -&gt; KEY PATTERN REPLACEMENT ...</h4>
<p>
Specify searchSubst rule, allowing rewrite of any part of the search
request.
</p>
When the incoming search request matches all KEY PATTERN pairs, Viper
performs the specified KEY=~ s/PATTERN/REPLACEMENT/ actions to rewrite
the incoming search.
</p>
<p>
Search rewriting is completely free-form, and it is possible to rewrite searches to a completely different Viper suffix, as long as both are located in the same base directory.
</p>
<p>
This is a legitimate feature of the rewrite model, and is officially used to
rewrite incoming DHCP search queries under ou=dhcp to appropriate places
and with appropriate options under ou=clients.
</p>
<p>
KEY can be one of base, scope, deref, size, time, filter, attrOnly. Rewriting
one last element of a search, the list of attributes to return, is currently
not possible, but the feature is on the way.
</p>
<p>
Examples: production examples used in rewriting ou=dhcp to ou=clients
<pre><protect>
Example 1:

# Solve lack of flexibility in ISC DHCP3 LDAP patch by
# plainly specifying ldap-base-dn "ou=dhcp" in DHCP's
# config, and then here, rewriting DHCP ethernet address
# lookup to the ou=clients tree under which all clients
# are defined.

searchSubst  base        "^ou=dhcp$"                       \
             filter      "^\\(&\\(objectClass=dhcpHost\\)\\(dhcpHWAddress=ethernet [\\dabcdef:]+\\)\\)$" \
             -&gt;                                            \
             base   .+   ou=clients


Example 2:

# Solve lack of flexibility in ISC DHCP3 LDAP patch by
# rewriting a search in any shared network, tree
# ou=dhcp, to a proper location,

searchSubst  base        "^ou=\\w+,ou=dhcp$"                \
             scope       "^1$"                             \
             filter      "^\\(objectClass=\\*\\)$"         \
             -&gt;                                            \
             base   .+   "ou=clients"                      \
             filter .+   "(&amp;(objectClass=dhcpSubnet)(!(cn=default)))" \
             scope  .+   2
</protect></pre>
</p>


<div class="fineline"></div>
flow (clean reset save *dump etc.)

<div class="fineline"></div>
<pre>
debugging options
</pre>
